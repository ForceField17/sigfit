% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sigfit_estimation.R
\name{extract_signatures}
\alias{extract_signatures}
\title{Extract mutational signatures}
\usage{
extract_signatures(
  counts,
  nsignatures,
  model = "multinomial",
  opportunities = NULL,
  sig_prior = NULL,
  exp_prior = NULL,
  dpp = FALSE,
  dpp_conc = 1,
  stanfunc = "sampling",
  chains = 1,
  ...
)
}
\arguments{
\item{counts}{Numeric matrix of observed mutation counts, with one row per sample and
one column per mutation type.}

\item{nsignatures}{Integer or integer vector indicating the number(s) of signatures to extract.}

\item{model}{Name of the model to sample from. Admits character values \code{"multinomial"}
(default), \code{"poisson"}, \code{"negbin"}, \code{"normal"}, \code{"nmf"} (an alias for
\code{"multinomial"}), and \code{"emu"} (an alias for \code{"poisson"}).}

\item{opportunities}{Numeric matrix of optional mutational opportunities, with one row per sample
and one column per mutation type. It also admits character values \code{"human-genome"} or
\code{"human-exome"}, in which case the mutational opportunities of the reference human
genome/exome will be used for every sample.}

\item{sig_prior}{Numeric matrix with one row per signature and one column per mutation type,
to be used as the Dirichlet priors for the mutational signatures. Only used when a single value
is provided for \code{nsignatures}. Default priors are uniform.}

\item{exp_prior}{Numeric matrix with one row per sample and one column per signature, to be used
as the Dirichlet priors for the signature exposures. Default priors are uniform.}

\item{dpp}{Logical indicating whether to use a Dirichlet process prior to infer the number of
mutational signatures (default is \code{FALSE}).}

\item{dpp_conc}{Numeric indicating the value of the concentration parameter for the Dirichlet
process prior (default is 1). Only used if \code{dpp=TRUE}.}

\item{stanfunc}{Character indicating the choice of rstan inference strategy.
Admits values \code{"sampling"}, \code{"optimizing"} and \code{"vb"}. The default value is
\code{"sampling"}, which corresponds to the full Bayesian MCMC approach. Alternatively,
\code{"optimizing"} returns the Maximum a Posteriori (MAP) point estimates via numerical
optimization, while \code{"vb"} uses Variational Bayes to approximate the full posterior.}

\item{chains}{Integer indicating the number of chains used for MCMC (default is 1). The use of
multiple chains for signature extraction is discouraged, as it can result in an inference problem
called 'label switching'. This value is passed to \code{\link{rstan::sampling}}.}

\item{...}{Additional arguments to be passed to the sampling function (by default,
\code{\link{rstan::sampling}}).}
}
\value{
A list with two elements:
\itemize{
 \item{\code{`data`}: list containing the input data supplied to the model.}
 \item{\code{`result`}: object of class stanfit, containing the output MCMC samples,
 as well as information about the model and the sampling process.}}
The model parameters (such as signatures and exposures) can be extracted from this object using
\code{\link{retrieve_pars}}.
If a range of numbers of signatures is provided via the \code{nsignatures} argument, a list is
returned in which the N-th element contains the extraction results for N signatures, as a list
with the structure described above.
}
\description{
\code{extract_signatures} performs MCMC sampling to infer a set of mutational signatures
and their exposures from a collection of mutational catalogues. Four models of signatures are
available: multinomial, Poisson, normal and negative binomial. The normal model can be used when
\code{counts} contains continuous (non-integer) values, while the negative binomial model is a
more noise-robust version of the Poisson model. (However, the use of the negative binomial model
for signature extraction is discouraged due to its inefficiency.)
}
\examples{
\dontrun{
# Load example mutational catalogues
data("counts_21breast")

# Extract 2 to 6 signatures using the NMF (multinomial) model
# (400 warmup iterations + 400 sampling iterations - use more in practice)
samples_nmf <- extract_signatures(counts_21breast, nsignatures = 2:6,
                                  model = "nmf", iter = 800)

# Extract 4 signatures using the EMu (Poisson) model
# (400 warmup iterations + 800 sampling iterations - use more in practice)
samples_emu <- extract_signatures(counts_21breast, nsignatures = 4, model = "emu",
                                  opportunities = "human-genome",
                                  iter = 1200, warmup = 400)
}
}

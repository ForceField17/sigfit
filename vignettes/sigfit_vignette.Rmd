---
title: "sigfit - fitting mutational signatures to SNP data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Usage guide}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressPackageStartupMessages(library(sigfit))
```
## Introduction

```sigfit``` is used to estimate the proportions in which a set of mutational signatures are acting on a genome. It requires two inputs: 
  
  - a vector of mutation counts - the number of times mutations of particular types (typically the 96 different tri-nucleotide contexts) occur in the genome
  
  - a matrix of mutational signatures, which describes the estimated probabilities of each mutational category being observed

## Installation

```sigfit``` is an R package. As it is in early development it is not on CRAN, but can be installed from github using ```devtools```.
```{r eval=FALSE}
devtools::install_github("kgori/sigfit", build_vignettes = TRUE)
```

## Usage guide

#### Generating data
This example will use the mutational signatures from [COSMIC](http://cancer.sanger.ac.uk/cosmic/signatures) to generate simulated mutation counts, and then use ```sigfit``` to fit the signatures back to the simulated data.

First of all we need some mutational signatures to fit to our data. This command will fetch mutational signatures from COSMIC.
```{r fetch}
sigs <- sigfit::fetch_cosmic_data(reorder = TRUE)  # reorder: sorts by substitution type and trinucleotide context
```

Let's use these signatures to simulate some mutation data. This code will generate 20000 mutations from a 4:3:2:1 mixture of signatures 1, 5, 7 and 11.
```{r sim}
set.seed(1)
probs <- c(0.4, 0.3, 0.2, 0.1) %*% as.matrix(sigs[c(1, 5, 7, 11), ])
mutations <- as.vector(rmultinom(1, 20000, probs))
names(mutations) <- colnames(sigs)
```

Here is what our simulated counts look like:
```{r fig.width=7.5, fig.height=5, plotsim}
barplot(mutations, cex.names = 0.4, las = 2)
```

#### Fitting signatures
Now we can estimate the exposure of the data to each signature (pretending we don't already know that it was generated from 1, 5, 7, 11). ```sigfit``` uses [Stan](http://mc-stan.org/) to run a Bayesian model that produces Markov Chain Monte Carlo samples. ```rstan::sampling``` arguments, such as ```iter```, ```warmup```, etc., can be passed through.
```{r include=FALSE}
set.seed(1)
mcmc_samples <- sigfit::fit_signatures(counts = mutations, signatures = sigs,
                                       iter = 1500, warmup = 500, seed = 1)
```

```{r eval=FALSE}
set.seed(1)
mcmc_samples <- sigfit::fit_signatures(counts = mutations, signatures = sigs,
                                       iter = 1500, warmup = 500, seed = 1)
```

#### Visualisation
We can look at the fitted spectrum using ```plot_spectrum```. This function can pass through arguments to ```barplot```
```{r fig.width=7.5, fig.height=5, echo=FALSE}
anon <- suppressWarnings(sigfit::plot_spectrum(mcmc_samples, names.arg = rownames(mutations),
                                                 cex.names = 0.4, las = 2))
```

```{r eval=FALSE}
sigfit::plot_spectrum(mcmc_samples, names.arg = rownames(mutations),
                        cex.names = 0.4, las = 2)
```

```plot_exposures``` produces a barplot of the inferred exposure of the sample to each signature. 

```{r fig.width=7.5, fig.height=5, exposures}
sigfit::plot_exposures(mcmc_samples, prob = 0.9, thresh = 0.01,
                         cex.names = 0.7, las = 2)
```

The bars in this plot are coloured blue if the estimated exposure value is 'sufficiently non-zero' - it is difficult for the model to make hard assignments of which signatures are present or absent due to the non-negative constraint on the estimate, which means that the range of values in the sample will not include zero. In practice, 'sufficiently non-zero' means that the lower end of the Bayesian HPD credible interval (`prob`) is above a threshold value (`thresh`).

In this example, ```sigfit``` has identified the 4 signatures used to construct the sample.

#### Multiple samples
Here is a similar example where we have multiple samples - 10 samples with 2000 mutations

```{r multisim}
set.seed(1)
probs <- c(0.4, 0.3, 0.2, 0.1) %*% as.matrix(sigs[c(1, 5, 7, 11), ])
mmutations <- t(rmultinom(10, 2000, probs))
colnames(mmutations) <- colnames(sigs)
```

```{r plotmultisim}
#par(mfrow = c(5, 2))
for (i in 1:nrow(mmutations)) barplot(mmutations[i, ], cex.names = 0.4, las = 2)
```

```{r include=FALSE}
set.seed(1)
mmcmc_samples <- sigfit::fit_signatures(counts = mmutations, signatures = sigs,
                                       iter = 1500, warmup = 500, seed = 1)
```

```{r eval=FALSE}
set.seed(1)
mmcmc_samples <- sigfit::fit_signatures(counts = mmutations, signatures = sigs,
                                       iter = 1500, warmup = 500, seed = 1)
```

#### Visualisation
Here is the best fit spectrum over all samples.
```{r fig.width=7.5, fig.height=5, echo=FALSE, eval=FALSE}
# NOT RUNNING FOR NOW
anon <- suppressWarnings(sigfit::plot_spectrum(mmcmc_samples, names.arg = rownames(mmutations),
                                                 cex.names = 0.4, las = 2))
```

```{r eval=FALSE}
sigfit::plot_spectrum(mmcmc_samples, names.arg = rownames(mmutations),
                        cex.names = 0.4, las = 2)
```

And the exposures
```{r fig.width=7.5, fig.height=5, multiexposures, eval=FALSE}
# NOT RUNNING FOR NOW
sigfit::plot_exposures(mmcmc_samples, prob = 0.9, thresh = 0.01,
                         cex.names = 0.7, las = 2)
```

___

```sigfit``` is an R package developed by the Transmissible Cancer Group in the University of Cambridge Department of Veterinary Medicine.

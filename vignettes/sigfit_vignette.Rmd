---
title: "sigfit - fitting mutational signatures to SNP data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Usage guide}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressPackageStartupMessages(library(sigfit))
par(mar = c(6, 4, 6, 4))
```
## Introduction

```sigfit``` is used to estimate the proportions in which a set of mutational signatures are acting on a genome. It requires two inputs: 
  
  - a vector of mutation counts - the number of times mutations of particular types (typically the 96 different tri-nucleotide contexts) occur in the genome
  
  - a matrix of mutational signatures, which describes the estimated probabilities of each mutational category being observed

## Installation

```sigfit``` is an R package. As it is in early development it is not on CRAN, but can be installed from github using ```devtools```.
```{r devtools_instructions, eval=FALSE}
devtools::install_github("kgori/sigfit", build_vignettes = TRUE)
```

## Usage guide

#### Generating data
This example will use the mutational signatures from [COSMIC](http://cancer.sanger.ac.uk/cosmic/signatures) to generate simulated mutation counts, and then use ```sigfit``` to fit the signatures back to the simulated data.

First of all we need some mutational signatures to fit to our data. This command will fetch mutational signatures from COSMIC.
```{r fetch}
sigs <- sigfit::fetch_cosmic_data(reorder = TRUE)  # reorder: sorts by substitution type and trinucleotide context
```

Let's use these signatures to simulate some mutation data. This code will generate 20000 mutations from a 4:3:2:1 mixture of signatures 1, 5, 7 and 11.
```{r sim}
set.seed(1)
probs <- c(0.4, 0.3, 0.2, 0.1) %*% as.matrix(sigs[c(1, 5, 7, 11), ])
mutations <- matrix(rmultinom(1, 20000, probs), nrow = 1)
colnames(mutations) <- colnames(sigs)
```

Here is what our simulated counts look like:
```{r fig.width=18, fig.height=12, out.width="100%", plotsim}
par(mar = c(6,4,6,4))
sigfit::plot_spectrum(mutations, counts = TRUE)
```

#### Fitting signatures
Now we can estimate the exposure of the data to each signature (pretending we don't already know that it was generated from 1, 5, 7, 11). ```sigfit``` uses [Stan](http://mc-stan.org/) to run a Bayesian model that produces Markov Chain Monte Carlo samples. ```rstan::sampling``` arguments, such as ```iter```, ```warmup```, etc., can be passed through.
```{r include=FALSE, silent_sampling}
set.seed(1)
mcmc_samples <- sigfit::fit_signatures(counts = mutations, signatures = sigs[c(1, 5, 7, 11), ],
                                       iter = 1000, chains = 1, warmup = 500, seed = 1)
```

```{r eval=FALSE, sampling}
set.seed(1)
mcmc_samples <- sigfit::fit_signatures(counts = mutations, signatures = sigs[c(1, 5, 7, 11), ],
                                       iter = 1000, chains = 1, warmup = 500, seed = 1)
```

#### Visualisation
We can look at the fitted spectrum using ```plot_spectrum```. This function can pass through arguments to ```barplot```
```{r fig.width=24, fig.height=16, out.width = '100%', echo=FALSE, silent_reconstruct}
par(mar=c(6,4,6,4))
anon <- suppressWarnings(
    sigfit::plot_reconstruction(mutations,
                                mcmc_samples = mcmc_samples,
                                signatures = sigs[c(1, 5, 7, 11), ])
    )
```

```{r eval=FALSE, reconstruct}
sigfit::plot_reconstruction(mutations, mcmc_samples = mcmc_samples,
                            signatures = sigs[c(1, 5, 7, 11), ])
```

```plot_exposures``` produces a barplot of the inferred exposure of the sample to each signature. 

```{r eval=FALSE, fig.width=7.5, fig.height=5, out.width = '75%', fig.align = "center", exposures}
plots <- sigfit::plot_exposures(mcmc_samples)
plots[[1]]
```

The bars in this plot are coloured blue if the estimated exposure value is 'sufficiently non-zero' - it is difficult for the model to make hard assignments of which signatures are present or absent due to the non-negative constraint on the estimate, which means that the range of values in the sample will not include zero. In practice, 'sufficiently non-zero' means that the lower end of the Bayesian HPD credible interval (`prob`) is above a threshold value (`thresh`).

In this example, ```sigfit``` has identified the 4 signatures used to construct the sample.

#### Multiple samples
Here is a similar example where we have multiple samples

```{r multisim}
set.seed(1)
probs <- rbind(c(0.4, 0.3, 0.2, 0.1) %*% as.matrix(sigs[c(1, 5, 7, 11), ]),
               c(0.75, 0.15, 0.05, 0.05) %*% as.matrix(sigs[c(1, 5, 7, 11), ]),
               c(0.1, 0.1, 0.45, 0.35) %*% as.matrix(sigs[c(1, 5, 2, 13), ]))
mmutations <- rbind(matrix(rmultinom(1, 9500, probs[1, ]), nrow=1),
                    matrix(rmultinom(1, 500, probs[1, ]), nrow=1),
                    matrix(rmultinom(1, 5000, probs[2, ]), nrow=1),
                    matrix(rmultinom(1, 5000, probs[3, ]), nrow=1))
colnames(mmutations) <- colnames(sigs)
```

```{r fig.width=24, fig.height=16, out.width = '100%', fig.align = "center", plotmultisim}
par(mfrow = c(2, 2), mar = c(6, 4, 6, 4))
for (i in 1:nrow(mmutations)) sigfit::plot_spectrum(spectra = mmutations[i, ], counts = TRUE)
```

```{r include=FALSE, silent_multisampling}
set.seed(1)
mmcmc_samples <- suppressWarnings(sigfit::fit_signatures(counts = mmutations, 
                                                         signatures = sigs[c(1, 2, 5, 7, 11, 13), ],
                                                         iter = 1000, chains = 1, 
                                                         warmup = 500, seed = 1))
```

```{r eval=FALSE, multisampling}
set.seed(1)
mmcmc_samples <- sigfit::fit_signatures(counts = mmutations, 
                                        signatures = sigs[c(1, 2, 5, 7, 11, 13), ],
                                        iter = 1000, chains = 1, warmup = 500, seed = 1)
```

#### Visualisation
Here are the best fit spectra for each sample.
```{r fig.width=24, fig.height=16, out.width="100%", echo=FALSE, silent_multireconstruct}
par(mar = c(6, 4, 6, 4))
anon <- suppressWarnings(
    sigfit::plot_reconstruction(mmutations, 
                                mcmc_samples = mmcmc_samples, 
                                signatures = sigs[c(1, 2, 5, 7, 11, 13), ])
)
```

```{r eval=FALSE, multireconstruct}
sigfit::plot_reconstruction(mmutations, 
                            mcmc_samples = mmcmc_samples, 
                            signatures = sigs[c(1, 2, 5, 7, 11, 13), ])
```

And the exposures
```{r eval=FALSE, fig.width=12, fig.height=8, out.width = "100%", echo=FALSE, silent_multiexposures}
plots <- sigfit::plot_exposures(mmcmc_samples)
invisible(m <- gridExtra::marrangeGrob(plots, nrow = 2, ncol = 2))
m
```

```{r eval=FALSE, multiexposures}
sigfit::plot_exposures(mmcmc_samples)
```

___

```sigfit``` is an R package developed by the Transmissible Cancer Group in the University of Cambridge Department of Veterinary Medicine.

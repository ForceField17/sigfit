---
title: "Fitting and extracting mutational signatures with sigfit"
author: "Kevin Gori and Adrian Baez-Ortega (2019)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Usage guide}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressPackageStartupMessages(library(sigfit))
par(mar = c(6, 4, 6, 4))
```


## Introduction

__sigfit__ is used to estimate signatures of mutational processes and their degree of activity on a collection of cancer (or normal) samples. Starting from a set of single-nucleotide variants (SNVs), it allows both estimation of the exposure of samples to predefined mutational signatures (including whether the signatures are present at all), and identification signatures _de novo_ from the mutation counts. These two procedures are often called, respectively, __signature fitting__ and __signature extraction__. In addition, sigfit implements novel 'Fit-Ext' models that combine signature fitting and extraction in a single inferential process. Furthermore, the signature analysis methods in sigfit can be seamlessly applied to mutational profiles beyond SNV data, including insertion/deletion (indel) or rearrangement count data. The package also provides a range of functions to generate publication-quality graphics of the corresponding mutational catalogues, signatures and exposures.


## Installation

sigfit is an R package. As it is in early development it is not yet on CRAN, but can be installed from GitHub using the [devtools](https://cran.r-project.org/web/packages/devtools/index.html) package.

```{r devtools_instructions, eval=FALSE}
devtools::install_github("kgori/sigfit", build_opts = c("--no-resave-data", "--no-manual"))
```

The solutions to some of the problems that may arise during installation are listed in the [README](https://github.com/kgori/sigfit/blob/master/README.md) file for the package.


## Usage guide

## Example 1: Fitting mutational signatures to a single simulated sample

This example will use the mutational signatures from [COSMIC](http://cancer.sanger.ac.uk/cosmic/signatures) to generate simulated mutation counts, and then use sigfit to __fit__ the signatures back to the simulated data.

First of all we need some mutational signatures to fit to our data. The line below loads the mutational signatures published in COSMIC.

```{r fetch}
data("cosmic_signatures_v2")
```

Let's use these signatures to __simulate__ some mutation data. This code will generate 20,000 mutations from a 4:3:2:1 mixture of signatures 1, 3, 7 and 11.

```{r sim}
set.seed(1)
probs <- c(0.4, 0.3, 0.2, 0.1) %*% as.matrix(cosmic_signatures_v2[c(1, 3, 7, 11), ])
mutations <- matrix(rmultinom(1, 20000, probs), nrow = 1)
colnames(mutations) <- colnames(cosmic_signatures_v2)
```

Here is what the __mutational spectrum__ of our simulated counts looks like:

```{r plotsim, fig.width=17, fig.height=6.5, out.width="100%", echo=-1}
par(mar = c(4.5,5.5,6.5,1))
sigfit::plot_spectrum(mutations, name = "Simulated counts")
```

### Fitting mutational signatures

Next, we can use the ```fit_signatures``` function in sigfit to estimate the __exposure__ of the data to each signature (pretending we ignore that it was generated from signatures 1, 3, 7 and 11). This function uses the [Stan](http://mc-stan.org/) framework to produces Markov chain Monte Carlo (MCMC) samples from a Bayesian model of signatures. Arguments to the ```rstan::sampling``` function, such as ```iter```, ```warmup```, ```chains```, ```seed```, etc., can be passed through. For further sampling options, type ```?rstan::sampling``` to read the documentation.

> __In general, one should run as many MCMC iterations (```iter``` argument) as one's computer and patience allow, with runtime being the major constraint.__

We recommend that the number of __warmup__ (burn-in) iterations (```warmup``` argument) be between one-third and half the value of ```iter```. The behaviour of the MCMC sampler (which ultimately affects the quality of the analysis) depends on parameters set during the warmup, so it is important to run plenty of warmup iterations. By default, ```rstan::sampling``` uses ```iter = 2000``` and ```warmup = floor(iter/2)```; going below these values is generally not advised. The ```chains``` argument can be used to parallelise the sampling process by using multiple Markov chains (the number of which should never exceed the number of processors), while the ```seed``` argument can be used to make the MCMC samples reproducible over different runs.

The ```fit_signatures``` function can be used to fit the COSMIC signatures to the simulated counts as follows.

```{r fitting, warning=FALSE}
mcmc_samples_fit <- sigfit::fit_signatures(counts = mutations, 
                                           signatures = cosmic_signatures_v2,
                                           iter = 2000, 
                                           warmup = 1000, 
                                           chains = 1, 
                                           seed = 1)
```

For details about further arguments of ```fit_signatures```, including alternative signature models, mutational opportunities and exposure priors, see the _Other functionalities_ section at the end of this vignette, or type ```?fit_signatures``` to read the documentation.

### Retrieving signature exposures

Once we have the result of the MCMC sampling in ```mcmc_samples_fit```, we can __retrieve__ the estimated exposures from it using the ```retrieve_pars``` function. This returns a named list with three matrices, one containing the __mean__ exposures, and the others containing the values corresponding to the lower and upper limits of the highest posterior density (__HPD__) interval (the Bayesian alternative to a confidence interval) for each signature exposure in each sample. The ```prob``` argument can be used to indicate the target probability content of the HPD interval (by default, 95% HPD intervals are returned).

Since we are fitting known signatures instead of extracting them _de novo_, the exposures will be automatically labelled with the signature names. If the signatures have no names (or have been extracted instead of fitted, as we will see below), they will be labelled as 'Signature A', 'Signature B', etc.

```{r retrieve_exp}
exposures <- sigfit::retrieve_pars(mcmc_samples_fit, 
                                   par = "exposures", 
                                   hpd_prob = 0.90)
names(exposures)
exposures$mean
```

The entire __posterior distribution__ of the signature exposures and other model parameters in the ```mcmc_samples_fit``` object can be further explored by means of the functions provided by the [rstan](http://mc-stan.org/rstan) package. In addition, [ShinyStan](http://mc-stan.org/users/interfaces/shinystan) can be easily used in R for visual exploration of the MCMC samples.

### Visualisation

sigfit provides several easy-to-use __plotting__ functions. As seen in the previous section, the ```plot_spectrum``` function allows visualisation of both __mutational catalogues__ and __mutational signatures__. These plots can be produced even for catalogues and signatures with arbitrary mutation types (for example, indel or rearrangement signatures).

The ```plot_exposures``` function produces a barplot of the estimated __signature exposures__ in each sample. It needs to be supplied with either the object resulting from MCMC sampling (```mcmc_samples``` argument) or the exposures themselves (```exposures``` argument), the latter being either a matrix, or a list like the one returned by the ```retrieve_pars``` function (see above). In the present case, since we have the stanfit object generated by ```fit_signatures```, we will make use of the ```mcmc_samples``` argument.

```{r plot_exp, fig.width=17, fig.height=7, out.width='100%', fig.align="center", echo=-1}
par(mar=c(8,5,3.5,0))
sigfit::plot_exposures(mcmc_samples = mcmc_samples_fit)
```

The bars in this plot are coloured blue if the estimated exposure value is 'sufficiently non-zero', and grey otherwise. It is difficult for the model to make hard assignments of which signatures are present or absent due to the non-negative constraint on the estimate, which means that the range of values in the sample will not normally include zero. In practice, 'sufficiently non-zero' means that the lower end of the Bayesian HPD credible interval is above a threshold value close to zero (by default 0.01, and adjustable via the ```thresh``` argument). In this example, sigfit has identified the 4 signatures used to construct the sample.

Next, we would recommend __re-running__ ```fit_signatures```, this time to fit only those signatures (i.e. those rows of the ```cosmic_signatures_v2``` matrix) which have been highlighted as 'sufficiently non-zero' in the plot above, in order to obtain more accurate estimates. This is done as follows.

```{r refitting, eval=FALSE}
selected_signatures <- c(1, 3, 7, 11)
mcmc_samples_fit_2 <- sigfit::fit_signatures(mutations, 
                                             cosmic_signatures_v2[selected_signatures, ],
                                             iter = 2000, 
                                             warmup = 1000, 
                                             chains = 1, 
                                             seed = 1)
```

We can also examine how effectively the estimated signatures and/or exposures can reconstruct the original count data, by producing __spectrum reconstruction__ plots with the ```plot_reconstruction``` function. 

> __Note that the plotting functions in sigfit are designed with a preference for plotting directly to a PDF file__.

The path to the desired output PDF can be provided using the ```pdf_path``` argument (but we will not make use of this option in the present example). When plotting to a PDF, each function will automatically select an appropriate plot size and graphical parameters, although custom sizes can be defined via additional arguments such as ```pdf_width``` and ```pdf_height``` (see the documentation for each function, e.g. ```?plot_reconstruction```).

```{r reconstruct, fig.width=25, fig.height=18.5, out.width='100%', warning=FALSE, results="hide", echo=-1}
par(mar=c(5,6,6.5,1))
sigfit::plot_reconstruction(mcmc_samples = mcmc_samples_fit,
                            pdf_path = NULL)
```

Finally, the ```plot_all``` function provides a simpler way of __simultaneously__ calling the ```plot_spectrum```, ```plot_exposures``` and ```plot_reconstructions``` functions for a single set of results. This function plots exclusively to PDF files, and the ```out_path``` argument is used to indicate the path of the directory where the files should be produced (if the directory does not yet exist, it will be automatically created). The ```prefix``` argument applies to the output file names, and can be used to distinguish different sets of plots from each other.

```{r plot_all, eval=FALSE}
sigfit::plot_all(mcmc_samples = mcmc_samples_fit, 
                 out_path = "your/output/dir/here",
                 prefix = "Fitting")
```


## Example 2: Extracting signatures from multiple breast cancer samples

### Generating mutational catalogues

In this second example, we will use single-nucleotide variant (SNV) data from the set of 21 breast cancer samples used by [Nik-Zainal _et al._ (2012)](http://dx.doi.org/10.1016/j.cell.2012.04.024). These data can be accessed using ```data("variants_21breast")```.

```{r load_mutations}
data("variants_21breast")
head(variants_21breast)
```

This __variant table__ illustrates the structure of the SNV data that can be used as input for the package (unless you already have mutational catalogues for your samples). It is a matrix or data frame with one row per variant, and four (or five) columns:

* __Sample ID__ (character, e.g. ```"Sample 1"```).
* __Reference base__ (character: ```"A"```, ```"C"```, ```"G"```, or ```"T"```).
* __Mutated base__ (character: ```"A"```, ```"C"```, ```"G"```, or ```"T"```).
* __Trinucleotide context__ of the variant (character; reference sequence between the positions immediately before (-1) and after (+1) the variant, e.g. ```"TCA"```). This can be obtained from the reference genome that was used to call the variants, using an R package like [BSgenome](https://bioconductor.org/packages/release/bioc/html/BSgenome.html); however, sequence context information is sometimes provided by variant callers within the 'INFO' field of the VCF file.
* __Optionally__: if information is available about the __transcriptional strand__ where each mutation occurred, this can be incorporated as a fifth column taking character values ```"1"``` / ```"U"``` (for the untranscribed strand) or ```"-1"``` / ```"T"``` (for the transcribed strand). If the table is a data frame, integer values ```1``` and ```-1``` are also admitted. If this column is present in the table, all the estimation and plotting functions will automatically incorporate transcriptional strand information. The interpretation of ```1``` and ```-1``` as the untranscribed and transcribed strands, respectively, allows direct use of the 'Strand' field that is normally provided by variant annotation tools, such as the [VEP](http://www.ensembl.org/info/docs/tools/vep/index.html). (Annotation tools use 'Strand' values of ```1``` and ```-1``` to indicate that the corresponding gene is located on the forward or reverse strand, respectively. Since mutations are always called on the forward strand, this value also indicates the transcriptional strand of mutations.)

Importantly, since a variant can only have a single sample ID, variants which are found in __more than one sample__ need to be included multiple times in the table, using different sample IDs. The order in which the samples are found in this table is the order in which they will be displayed thereafter. In this case, the samples are already sorted alphabetically:
 
```{r show_samples}
unique(variants_21breast[, 1])
```

The first step is to transform these variants into __mutational catalogues__, which is done by the ```build_catalogues``` function. (You can skip this step if you already have mutational catalogues for your samples.)

```{r build_catalogues}
counts_21breast <- sigfit::build_catalogues(variants_21breast)
dim(counts_21breast)
counts_21breast[1:5, 1:8]
```

The mutational catalogues are stored as a matrix of __mutation counts__, where each row refers to a sample and each column corresponds to a trinucleotide mutation type.

(This example set of 21 mutational catalogues can also be loaded directly using ```data("counts_21breast")```).

We can plot the __spectra__ of all the mutational catalogues using the ```plot_spectrum``` function, as in the previous example. For tables containing more than one catalogue, this function will produce one plot per catalogue, which makes using an output PDF file (```pdf_path``` argument) more convenient. In this example, however, we will plot all the catalogues together in a grid.

```{r plot_spectra, fig.width=22, fig.height=23, out.width='100%', fig.align="center", echo=-1}
par(mar = c(5,6,7,2))
par(mfrow = c(7, 3))
sigfit::plot_spectrum(counts_21breast)
```

### Extracting mutational signatures _de novo_

To __extract__ signatures from this set of catalogues, we use the ```extract_signatures``` function, specifying the __number of signatures__ to extract via the ```nsignatures``` argument; this can be a single integer value or a range, e.g. ```3:6```. The recommended approach is first running the function for a small number of iterations and a reasonably wide range of numbers of signatures (e.g. ```nsignatures = 2:8```). When ```nsignatures``` takes a range of values, sigfit will automatically determine the __most plausible__ number of signatures present in the data (which is done by assessing goodness-of-fit through the ```plot_gof``` function).

Note that, for the automatically determination method to work, ```nsignatures``` should include at least __four__ values, and its range should go beyond the "reasonable" range for the number of signatures; for example, if the number of signatures is expected to lie between 3 and 8, ```nsignatures``` could take values ```2:10```. Also, note that for ranges of ```nsignatures``` the result will be a list, in which element ```[[N]]``` corresponds to the extraction results for ```nsignatures = N```.

The number of chains (```chains``` argument) in ```extract_signatures``` has a default value of 1. __It is not advised to use multiple chains for signature extraction__, as this can result in a problem known as __label switching__ which can invalidate the inferences.

```{r extraction, eval=FALSE}
mcmc_samples_extr <- sigfit::extract_signatures(counts = counts_21breast,
                                                nsignatures = 2:7,
                                                iter = 1000, 
                                                seed = 1)
```

```{r plot_gof_silent, echo=FALSE, fig.width=9, fig.height=6, out.width="100%"}
## Plot precalculated GOF in order to avoid running the model
data("sigfit_vignette_data", package = "sigfit")
plot(nS, gof, type = "o", lty = 3, pch = 16, col = "dodgerblue4",
     main = paste0("Goodness-of-fit (", stat, ")\nmodel: NMF"),
     xlab = "Number of signatures", 
     ylab = paste0("Goodness-of-fit (", stat, ")"))
points(nS[best], gof[best], pch = 16, col = "orangered", cex = 1.1)
cat("Estimated best number of signatures:", nS[best], "\n")
```

The plot above shows that the most plausible number of signatures is four, based on the evolution of the goodness-of-fit (reconstruction accuracy measured through cosine similarity).

Next, it is recommended to __re-run__ the ```extract_signatures``` function, this time with ```nsignatures = 4``` and a much larger number of iterations, to obtain more-accurate estimates. We will skip this step in the present example.

For details about further arguments of ```extract_signatures```, including alternative signature models, mutational opportunities, signature/exposure priors, and Dirichlet process priors, see the _Other functionalities_ section at the end of this vignette, or type ```?extract_signatures``` to read the documentation.

### Retrieving, plotting and re-fitting extracted signatures

As in the case of signature fitting (see above), the extracted signatures and exposures can be retrieved using the ```retrieve_pars``` function with ```par = "signatures"``` or ```par = "exposures"```. However, because the output is a list containing the results for each value in ```nsignatures```, __we need to specify which  number of signatures we are interested in, using the ```[[ ]]``` operator__. Note that this is not necessary if a single value of ```nsignatures``` was used for extraction.

```{r extr_names, eval=FALSE}
names(mcmc_samples_extr)
```
```{r extr_names_silent, echo=FALSE}
print(c("nsignatures=1", "nsignatures=2", "nsignatures=3", "nsignatures=4", "nsignatures=5", "nsignatures=6", "nsignatures=7", "best"))
signatures <- extr_signatures
```
```{r retrieve_sigs, eval=FALSE}
## Note: mcmc_samples_extr[[N]] contains the extraction results for N signatures
signatures <- sigfit::retrieve_pars(mcmc_samples_extr[[4]],
                                    par = "signatures")
```
```{r show_signames}
rownames(signatures$mean)
```

__Plotting__ can be done through the functions seen in Example 1, with the difference that, when plotting directly from MCMC results (via the ```mcmc_samples``` argument), we need to select the relevant element of the results list using ```mcmc_samples_extr[[N]]```, as seen above. Note that this is not necessary if a single value of ```nsignatures``` was used for extraction.

Below we plot the signatures extracted from these 21 catalogues.

```{r plot_sigs, warning=FALSE, fig.width=25, fig.height=10, out.width='100%', fig.align="center", echo=-1}
par(mar = c(6,7,6,1))
par(mfrow = c(2, 2))
sigfit::plot_spectrum(signatures)
```

These are a combination of COSMIC signatures 1, 2, 3, 5 and 13. Note that the signatures published in [COSMIC](http://cancer.sanger.ac.uk/cosmic/signatures) were obtained using a collection of hundreds of catalogues across many cancer types, which offered much higher statistical power than the 21 breast cancer catalogues employed here. Furthermore, the signatures obtained by sigfit show high similarity to those originally reported by [Nik-Zainal _et al._ (2012)](http://dx.doi.org/10.1016/j.cell.2012.04.024) (Fig. 2A). Note that signatures C and D in Nik-Zainal _et al._, which are very similar, have been identified by sigfit as a single signature (Signature B in the plot above).

The extracted signatures can be __compared__ against a set of known signatures, such as the COSMIC signatures, to identify the best match for each signature, using the ```match_signatures``` function. This returns, for each signature in the first set, the index of the best match in the second signature set.

```{r match_sigs}
data("cosmic_signatures_v2")
sigfit::match_signatures(signatures, cosmic_signatures_v2)
```

In this case, the extracted signatures A, B, C and D have COSMIC signatures 2, 3, 13 and 1 as their closest matches, respectively.

As a last remark, after definitive signatures have been extracted by re-running ```extract_signatures``` for a single value of ```nsignatures```, it might be useful to __re-fit__ these definitive signatures back to the original catalogues, as this sometimes results in more-accurate signature exposures. Assuming that the MCMC samples from the definitive signature extraction are in an object named ```mcmc_samples_extr_2```, this is done as follows.

```{r refitting2, eval=FALSE}
signatures <- retrieve_pars(mcmc_samples_extr_2, "signatures")
mcmc_samples_refit <- fit_signatures(counts = counts_21breast,
                                     signatures = signatures,
                                     iter = 2000,
                                     warmup = 1000)
exposures <- retrieve_pars(mcmc_samples_refit, "exposures")
```

## Other functionalities

### Alternative signature models

By default, both ```fit_signatures``` and ```extract_signatures``` make use of an NMF-inspired Dirichlet–Multinomial model of signatures, which is statistically equivalent to the non-negative matrix factorisation (NMF) approach pioneered by [Alexandrov _et al._ (2013)](https://www.nature.com/articles/nature12477). Alternatively, users who are interested in the Poisson model presented by [Fischer _et al._ (2013)](https://doi.org/10.1186/gb-2013-14-4-r39) can use the ```model = "emu"``` option to select this model, which is able to account for variation in mutational opportunity (the opportunity for each mutation type to occur in each sample's genome; this is specified via the ```opportunities``` argument). For further details, type ```?extract_signatures``` to read the documentation.

Although signature representations differ between the NMF model and the EMu model (insofar as signatures obtained through the latter are not relative to the mutational opportunities of a specific genome/exome), signatures can be converted between both model representations by means of the ```convert_signatures``` function. For further details, type ```?convert_signatures``` to read the documentation.

### Using mutational opportunities and signature/exposure priors

...

### Converting between genome- and exome-relative representations of signatures

In some analyses, signatures that have been inferred from whole-genome mutation data need to be fitted to mutation data from whole-exome sequencing samples. For instance, if the cohort of samples includes both whole genomes and exomes, it is normally advisable to extract signatures from the whole-genome samples (provided that there are enough of them) and re-fit the resulting signatures to the whole-exome samples. (An alternative approach would be using the EMu/Poisson model mentioned above, with a matrix of sample-specific mutational opportunities that reflects the origin of each catalogue.)

To convert a matrix of genome-derived mutational signatures into their exome-relative representations, the ```convert_signatures``` function needs to be applied twice: once to normalise the signatures by the whole-genome mutational opportunities (using arguments ```ref_opportunities = "human-genome", model_to = "emu"```), and once again to impose whole-exome opportunities (using ```ref_opportunities = "human-exome", model_to = "nmf"```). An example is shown below.

```{r convert_sigs, eval=F}
# Following from the signature extraction example above
genome_signatures <- sigfit::retrieve_pars(mcmc_samples_extr[[4]],
                                           par = "signatures")
normalised_signatures <- sigfit::convert_signatures(genome_signatures, 
                                                    ref_opportunities = "human-genome",
                                                    model_to = "emu")
exome_signatures <- sigfit::convert_signatures(normalised_signatures, 
                                               ref_opportunities = "human-exome",
                                               model_to = "nmf")

par(mfrow = c(2, 1))
sigfit::plot_spectrum(genome_signatures$mean[4,], name = "Signature D, Genome-relative probabilities")
sigfit::plot_spectrum(exome_signatures[4,], name = "Signature D, Exome-relative probabilities")
```

```{r convert_sigs_silent, echo=F, fig.width=20, fig.height=14, out.width="100%"}
genome_signatures <- signatures
normalised_signatures <- sigfit::convert_signatures(genome_signatures, ref_opportunities="human-genome", model_to="emu")
exome_signatures <- sigfit::convert_signatures(normalised_signatures, ref_opportunities="human-exome", model_to="nmf")
par(mfrow = c(2, 1), mar = c(5,5.5,6.5,1))
sigfit::plot_spectrum(genome_signatures$mean[4,], name="Signature D, Genome-relative probabilities")
sigfit::plot_spectrum(exome_signatures[4,], name="Signature D, Exome-relative probabilities")
```

### Using Fit-Ext models to discover rare or novel signatures

One novelty in sigfit is the introduction of Fit-Ext models, which are able to extract mutational signatures _de novo_ while fitting a set of predefined signatures that are already known to be present in the data. Such models are useful for the discovery of rare signatures for which there is some qualitative evidence, but insufficient support as to allow deconvolution via conventional methods; or in cases where only signature fitting is possible, yet the data clearly display a mutational pattern which cannot be captured by the available signatures. For further details on the Fit-Ext models, see the sigfit [paper](https://www.biorxiv.org/content/early/2018/07/20/372896).

The Fit-Ext models can be accessed via the ```fit_extract_signatures``` function. This is used similarly to ```extract_signatures```, with the exception that a matrix of known signatures to be fitted needs to be provided via the ```signatures``` argument (as in ```fit_signatures```), and that the number of additional signatures to extract is provided via the ```num_extra_sigs``` argument. Unlike the ```nsignatures``` argument in ```extract_signatures```, ```num_extra_sigs``` currently admits only scalar values. For further details, type ```?fit_extract_signatures``` to read the documentation.

### Using the Dirichlet process prior to determine the number of signatures (experimental)

...

### List of available data sets

sigfit includes the following data sets, which can be loaded using the `data` function.

* Two collections of __COSMIC mutational signatures__: original set of 30 signatures (v2, 2015) and new set of 63 signatures (v3, 2019). The latter set is also available in transcriptional strand-wise version (192 mutation types). These data can be loaded using:

```{r}
    data("cosmic_signatures_v2")
    data("cosmic_signatures_v3")
    data("cosmic_signatures_v3_strand")
```

* Mutation table and mutational catalogues (96 mutation types) for the set of __21 breast cancer genomes__ used in [Nik-Zainal _et al._ (2012)](http://dx.doi.org/10.1016/j.cell.2012.04.024). These data can be loaded using:

```{r}
    data("variants_21breast")
    data("counts_21breast")
```

* Mutation tables and mutational catalogues (96 and 192 mutation types) for the set of __119 breast cancer genomes__ used in [Alexandrov _et al._ (2013)](https://doi.org/10.1038/nature12477). These data can be loaded using:

```{r}
    data("variants_119breast")
    data("variants_119breast_strand")
    data("counts_119breast")
    data("counts_119breast_strand")
```

* Mutation tables and mutational catalogues (96 and 192 mutation types) for the set of __88 liver cancer genomes__ used in [Alexandrov _et al._ (2013)](https://doi.org/10.1038/nature12477). These data can be loaded using:

```{r}
    data("variants_88liver")
    data("variants_88liver_strand")
    data("counts_88liver")
    data("counts_88liver_strand")
```

* Catalogues composed of __methylation beta values__ for 50 breast cancers and 27 normal solid tissue samples, obtained from the [TCGA repository](https://portal.gdc.cancer.gov/repository) (project BRCA). These catalogues contain 99 'mutation types', corresponding to beta values for 99 CpG sites in the promoters of genes associated with breast cancer in COSMIC (see the sigfit [paper](https://doi.org/10.1101/372896) for details). These data can be loaded using:

```{r}
    data("methylation_50breast")
    data("methylation_27normal")
```

___

sigfit is an R package developed by the [Transmissible Cancer Group](http://www.tcg.vet.cam.ac.uk/) in the University of Cambridge Department of Veterinary Medicine.
